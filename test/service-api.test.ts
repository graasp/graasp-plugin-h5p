import cs from 'checksum';
import FormData from 'form-data';
import fs from 'fs';
import fsp from 'fs/promises';
import { StatusCodes } from 'http-status-codes';
import LightMyRequest from 'light-my-request';
import path from 'path';
import tmp, { DirectoryResult } from 'tmp-promise';
import { createMock } from 'ts-auto-mock';
import util from 'util';

import fastify, { FastifyInstance, FastifyLoggerInstance } from 'fastify';

import {
  Actor,
  DatabaseTransactionHandler,
  Item,
  ItemMembershipTaskManager,
  ItemTaskManager,
  TaskRunner,
} from 'graasp';
import { ServiceMethod } from 'graasp-plugin-file';

import { H5P_ITEM_TYPE } from '../src/constants';
import { H5PService } from '../src/service';
import plugin from '../src/service-api';
import { H5PExtra } from '../src/types';
import { H5P_PACKAGES, MOCK_ITEM, MOCK_MEMBER } from './fixtures';
import {
  mockCreateCreateItemTaskSequence,
  mockCreateGetMembershipTask,
  mockCreateGetTask,
  mockRunSingle,
  mockRunSingleSequence,
} from './mocks';

const checksum = {
  file: util.promisify(cs.file),
};

describe('Service plugin', () => {
  /* mocks */
  const mockItemTaskManager = createMock<ItemTaskManager>();
  const mockItemMembershipTaskManager = createMock<ItemMembershipTaskManager>();
  const mockTaskRunner = createMock<TaskRunner<Actor>>();
  const mockDbTrxHandler = createMock<DatabaseTransactionHandler>();
  const mockLogger = createMock<FastifyLoggerInstance>();

  /** spies */
  let createItemSpy: jest.SpyInstance;
  let getItemSpy: jest.SpyInstance;
  let getMembershipSpy: jest.SpyInstance;
  let runSingle: jest.SpyInstance;
  let runSingleSequenceSpy: jest.SpyInstance;

  /* params */
  let tmpDir: DirectoryResult;
  const pathPrefix = 'h5p';

  /** instance under test */
  let app: FastifyInstance;

  beforeAll(async () => {
    tmpDir = await tmp.dir({ unsafeCleanup: true });

    app = fastify();

    app.decorate('items', { taskManager: mockItemTaskManager });
    app.decorate('itemMemberships', { taskManager: mockItemMembershipTaskManager });
    app.decorate('taskRunner', mockTaskRunner);
    app.decorateRequest('member', MOCK_MEMBER);

    createItemSpy = mockCreateCreateItemTaskSequence(mockItemTaskManager);
    getItemSpy = mockCreateGetTask(mockItemTaskManager);
    getMembershipSpy = mockCreateGetMembershipTask(mockItemMembershipTaskManager);
    runSingle = mockRunSingle(mockTaskRunner, mockDbTrxHandler, mockLogger);
    runSingleSequenceSpy = mockRunSingleSequence(mockTaskRunner, mockDbTrxHandler, mockLogger);

    // uuid schema referenced from h5pImport schema should be registered by core
    // we use a simple string schema instead
    app.addSchema({
      $id: 'http://graasp.org/',
      type: 'object',
      definitions: {
        uuid: { type: 'string' },
      },
    });

    await app.register(plugin, {
      serviceMethod: ServiceMethod.LOCAL,
      serviceOptions: {
        local: {
          storageRootPath: tmpDir.path,
        },
        // todo: file service refactor should not require both configs
        s3: {
          s3Region: 'mock-s3-region',
          s3Bucket: 'mock-s3-bucket',
          s3AccessKeyId: 'mock-s3-access-key-id',
          s3SecretAccessKey: 'mock-s3-secret-access-key',
        },
      },
      pathPrefix,
    });
  });

  afterAll(async () => {
    await tmpDir.cleanup();
  });

  it('decorates the fastify instance with h5p service', () => {
    expect(app.h5p).toBeDefined();
    expect(app.h5p instanceof H5PService).toBeTruthy();
  });

  describe('Upload valid .h5p package', () => {
    const h5pFileName = path.basename(H5P_PACKAGES.ACCORDION.path);
    const mockParentId = 'mock-parent-id';

    let res: LightMyRequest.Response,
      json: Item<H5PExtra>,
      contentId: string,
      expectedExtra: H5PExtra,
      expectedMetadata: Partial<Item<H5PExtra>>;

    beforeAll(async () => {
      const formData = new FormData();
      formData.append('file', fs.createReadStream(H5P_PACKAGES.ACCORDION.path));

      res = await app.inject({
        method: 'POST',
        url: '/h5p-import',
        payload: formData,
        headers: formData.getHeaders(),
        query: { parentId: mockParentId },
      });

      json = res.json();

      // contentId is generated by the server so we have to retrieve it from response
      contentId = json.extra.h5p.contentId;

      expectedExtra = {
        h5p: {
          contentId,
          h5pFilePath: `${contentId}/${h5pFileName}`,
          contentFilePath: `${contentId}/content`,
        },
      };

      expectedMetadata = {
        name: h5pFileName,
        type: H5P_ITEM_TYPE,
        extra: expectedExtra,
      };
    });

    it('returns the created item object', () => {
      expect(res.statusCode).toEqual(StatusCodes.OK);
      expect(json).toEqual({
        ...MOCK_ITEM,
        ...expectedMetadata,
      });
    });

    it('creates the item through the item service', () => {
      expect(createItemSpy).toHaveBeenCalledTimes(1);
      expect(createItemSpy).toHaveBeenCalledWith(MOCK_MEMBER, expectedMetadata, mockParentId);
      const usedCreateItemSequence = createItemSpy.mock.results[0].value;
      expect(runSingleSequenceSpy).toHaveBeenCalledWith(usedCreateItemSequence);
    });

    it('validates the write permission in parent if it exists', () => {
      expect(getItemSpy).toHaveBeenCalledTimes(1);
      expect(getItemSpy).toHaveBeenCalledWith(MOCK_MEMBER, mockParentId);
      expect(getMembershipSpy).toHaveBeenCalledTimes(1);
      expect(getMembershipSpy).toHaveBeenCalledWith(MOCK_MEMBER);
      const usedGetItemTask = getItemSpy.mock.results[0].value;
      const usedGetMembershipTask = getMembershipSpy.mock.results[0].value;
      expect(runSingleSequenceSpy).toHaveBeenCalledWith([usedGetItemTask, usedGetMembershipTask]);
    });

    it('extracts the files correctly', async () => {
      // root extraction folder exists
      const root = path.resolve(tmpDir.path, pathPrefix, contentId);
      expect(fs.existsSync(root)).toBeTruthy();
      // .h5p package exists and is same file as original
      const h5pFile = path.resolve(root, h5pFileName);
      expect(fs.existsSync(h5pFile)).toBeTruthy();
      expect(await checksum.file(h5pFile)).toEqual(
        await checksum.file(H5P_PACKAGES.ACCORDION.path),
      );
      // content folder exists
      const contentFolder = path.resolve(root, 'content');
      expect(fs.existsSync(contentFolder)).toBeTruthy();
      // h5p.json manifest file exists and is same file as original
      const manifestFile = path.resolve(contentFolder, 'h5p.json');
      expect(fs.existsSync(manifestFile)).toBeTruthy();
      const parsedManifest = JSON.parse(await fsp.readFile(manifestFile, { encoding: 'utf-8' }));
      expect(parsedManifest).toEqual(H5P_PACKAGES.ACCORDION.manifest);
    });

    it('removes the temporary extraction folder', () => {});
  });
});
